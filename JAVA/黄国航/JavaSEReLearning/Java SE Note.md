[TOC]
###  继承

- 继承是面向对象三大特征之一，可以使得子类具有父类的属性和方法，还可以在子类中重新定义、追加属性和方法。

- 格式：`public class 子类名 extends 父类名{}`
- 父类：也被称为基类、超类
- 子类：也被称为派生类
- 继承中子类的特点：
  - 子类可以有父类的内容
  - 子类还可以有自己特有的内容

#### 继承的好处和弊端

- 继承好处
  - 提高了代码的复用性
  - 提高了代码的维护性（方法代码需要修改，修改一处即可）
- 继承弊端
  - 继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性。
- 什么时候使用继承
  - 继承体现的关系：is a（猫是一种动物）

#### 继承中变量的访问特点

在子类方法中访问一个变量

- 在子类局部范围找
- 子类成员范围找
- 父类成员范围找
- 找父亲的父亲……
- 没有就报错

#### super 关键字

- super与this类似

  - this：代表对本类对象的引用

  - super：代表对父类存储空间的标识（可以理解为父类对象引用）

- 用法

  - 它可以向上在父类中找到父类的成员，直到找到为止（如在父类的父类中）。

  - `super.成员变量`：访问父类成员变量
  - `super(...)`：访问父类构造方法
  - `super.成员方法(...)`：访问父类成员方法

#### 继承中构造方法的访问特点

- 每一个子类构造方法的第一条语句默认都是`super()`
- 如果父类中没有无参构造方法，只有带参构造方法：
  - 需要通过使用super关键字去显式地调用父类的带参构造方法。
  - 或：在父类中自己提供一个无参构造方法。

#### 继承中成员方法的访问特点

- 通过子类对象访问一个方法
  - 先到子类成员范围去找
  - 父类成员范围找
  - 父亲的父亲中去找
  - 没有就报错

#### 方法重写（Override）

- 概述

  子类中出现了和父类中一模一样的方法声明、

- 应用

  当子类需要父类的功能，而功能主体子类有自己特有内容是，可以重写父类中的方法，这样，既沿袭了父类的功能，右定义了子类的内容。

- 使用`@override`注解可以帮助检查重写方法的方法声明的正确性。

- 方法重写的注意事项

  - 父类中私有方法子类不能重写（父类私有成员子类是不能继承的）。
  - 子类方法访问权限不能更低（`public`>默认>`private`）

#### Java中继承的注意事项

- Java类只支持单个继承，不支持多个继承。

  如Son类不能同时`extend Father， Mother`。

- 但支持多层继承。

  如Father类继承GrandDad类，Son类继承Father类。

### 修饰符

#### 包package

- 作用：对类进行分类和管理

- 格式：`package 报名`（多级包用`.`分开）

- 带包的java类编译和执行
  - 手动建包：
    1. 按照以前的格式编译Java文件`javac HelloWorld.java`
    2. 手动创建包（建文件夹）
    3. 将编译的.class文件放进文件夹的最里面中。
    4. 带包执行 `java 包名.HelloWorld`
  - 自动建包：
    1. `javax -d. HelloWorld.java`
    2. `java 包名.HelloWorld`

- 导包import

  `import 包名`

#### 权限修饰符

- private：只能在同一个类中访问
- 默认：只能在同一个类中、或同一个包中的子类和无关类中访问
- protected：可以在同一个类中、或同一个包中的子类和无关类、或不同包中的子类进行访问
- public：在同一个类中、同一个包中子类和无关类、不同包中的子类和无关类都可进行访问

#### 状态修饰符final和static

##### final

- 意为最终， 可以修饰类、成员方法、成员变量。
- final修饰的特点：
  - 修饰方法：表明该方法是最终方法，不能被重写
  - 修饰变量：表明该变量是常量，不能再次被赋值
  - 修饰类：表明该类是最终类，不能被继承
- final修饰局部变量
  - 变量是基本类型：final修饰指的是基本类型的数据值不能发生改变
  - 变量是引用类型：final 修饰指的是引用类型的地址值不能发生改变，但是地址里面的内容可以发生改变。

#### static

- 静态的意思，可以修饰成员方法、成员变量。
- static修饰的特点
  - 被类的所有对象共享，这也是我们判断是否要使用静态关键字的条件。
  - 可以通过类名调用（也可以通过对象名调用，不推荐）

- static访问的特点
  - 静态成员方法只能访问静态成员（变量、方法）



### 多态

- 概述

  同一个对象，在不同时刻表现出来 的不同形态

  比如：

  - 猫是猫：`Cat cat = new Cat()`（在内存中申请的空间仍为Cat对象的空间）
  - 猫是动物：`Animal cat = new Cat()`

  这里的猫在不同时刻表现出来了不同的形态，这就是多态。

- 多态的前提和体现
  - 有继承或实现关系
  - 有方法重写（有同一个方法如`Cat.eat()`和`Animal.eat()`）
  - 有父类引用指向子类对象（如`Animal cat = new Cat()`）

#### 多态中成员访问特点

- 访问成员变量：编译看左边，执行看左边

  全部取决于修饰类型的成员变量，如`Animal cat = new Cat()`,通过cat访问到的全为Animal对象的成员变量

- 访问成员方法：编译看左边，执行看右边。

  如`Animal cat = new Cat()`，其在编译过程中，只将cat编译为一个Animal对象，该对象无法访问Cat类型的独有方法，而只能访问Animal中的方法，但如果Cat中重写了Animal的方法，那么通过cat访问的方法实际执行的会是Cat类中重写的方法。

#### 多态的优点和弊端

- 好处：提高了程序的扩展性

  具体体现 ：定义方法的时候，使用父类型作为参数，将来在使用的时候，使用具体的子类型参与操作。

- 弊端：不能使用子类的特有方法

#### 多态中的转型

- 向上转型

  从子到父

  父类引用指向子类对象

- 向下转型

  - (**前提是这个父类的引用在创建对象时就是创建的该子类的对象，否则会抛出ClassCastException**)

  从父到子

  父类引用转为子类对象

